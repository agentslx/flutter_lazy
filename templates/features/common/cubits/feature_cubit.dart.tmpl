import 'dart:developer';

import 'package:easy_localization/easy_localization.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:formz/formz.dart';

import '../../../../di.dart';
import '../../data/models/{{ FEATURE_NAME_SNAKE }}_model.dart';
import '../../data/repository/{{ FEATURE_NAME_SNAKE }}_repository.dart';

part '{{ FEATURE_NAME_SNAKE }}_state.dart';

class {{ FEATURE_NAME_PASCAL }}Cubit extends Cubit<{{ FEATURE_NAME_PASCAL }}State> {
  {{ FEATURE_NAME_PASCAL }}Cubit() : super(const {{ FEATURE_NAME_PASCAL }}State());

  final {{ FEATURE_NAME_PASCAL }}Repository _repository = getIt<{{ FEATURE_NAME_PASCAL }}Repository>();

  /// Initialize the cubit and load data
  Future<void> initialize() async {
    if (state.status.isInProgress) return;
    emit(state.copyWith(status: FormzSubmissionStatus.inProgress));

    try {
      final result = await _repository.getData();
      result.fold(
        (failure) {
          emit(
            state.copyWith(
              status: FormzSubmissionStatus.failure,
              errorMessage: failure.message,
            ),
          );
        },
        (data) {
          emit(state.copyWith(
            status: FormzSubmissionStatus.success,
            items: [data],
          ));
        },
      );
    } catch (e, stackTrace) {
      log('Error in initialize', error: e, stackTrace: stackTrace);
      emit(state.copyWith(
        status: FormzSubmissionStatus.failure,
        errorMessage: e.toString(),
      ));
    }
  }

  /// Load details for a specific item
  Future<void> loadItemDetails(String id) async {
    emit(state.copyWith(status: FormzSubmissionStatus.inProgress));

    try {
      // In a real implementation, you would fetch the specific item
      // For the template, we'll just use sample data
      final result = await _repository.getData();
      result.fold(
        (failure) {
          emit(state.copyWith(
            status: FormzSubmissionStatus.failure,
            errorMessage: failure.message,
          ));
        },
        (data) {
          emit(state.copyWith(
            status: FormzSubmissionStatus.success,
            selectedItem: data,
          ));
        },
      );
    } catch (e) {
      emit(state.copyWith(
        status: FormzSubmissionStatus.failure,
        errorMessage: e.toString(),
      ));
    }
  }

  /// Create a new item
  Future<void> createItem({required String title, required String description}) async {
    emit(state.copyWith(status: FormzSubmissionStatus.inProgress));

    try {
      final result = await _repository.create{{ FEATURE_NAME_PASCAL }}(
        title: title,
        description: description,
      );

      result.fold(
        (failure) {
          emit(state.copyWith(
            status: FormzSubmissionStatus.failure,
            errorMessage: failure.message,
          ));
        },
        (item) {
          final updatedItems = [...state.items, item];
          emit(state.copyWith(
            status: FormzSubmissionStatus.success,
            items: updatedItems,
            successMessage: '{{ FEATURE_NAME_SNAKE }}.item_created_success'.tr(),
          ));
        },
      );
    } catch (e) {
      emit(state.copyWith(
        status: FormzSubmissionStatus.failure,
        errorMessage: e.toString(),
      ));
    }
  }

  /// For backward compatibility with older code
  Future<void> load() async {
    await initialize();
  }
}
